// The eDIDIO S10 Protocol Buffer Structure
// Version Number 1.1.18

syntax = "proto3";

//package com.eds10pb; // <- Uncomment for API generation


/*********** @exclude ENUMERATIONS/Types ************/
enum TriggerOperationType {
    MOMENTARY             = 0;   // A Short Press occurs when a button is pressed for less than 250ms (and at least 50ms). A Long Press occurs when a button is pressed for longer than 650ms. Holding the button down will repeat the Long Press action every 400ms.
    LATCHING              = 1;   // Instantaneous on short to ground (debounced to 50ms). Trigger occurs once upon entering this state (LOW) and once upon leaving this state (HIGH).
    MOMENTARY_OUTPUT      = 2;   // A temporary output signal
    LATCHING_OUTPUT       = 3;   // A continous output signal
	ROTARY				  = 4;   // Rotary device, DALI input device
    MOMENTARY_DISABLED    = 128; // Used to track the enabled/disabled state of an I/O
    LATCHING_DISABLED     = 129; // Used to track the enabled/disabled state of an I/O
}


enum TriggerType {
	DALI_ARC                            = 0;    // For controlling DALI Arc Levels (0 to 254) and 255 for MASK
	DALI_COMMAND                        = 1;    // See (https://en.wikipedia.org/wiki/Digital_Addressable_Lighting_Interface#Commands_for_control_gear) for a list of common DALI commands
	DMX_CHANNELS_SPLIT_LOW              = 2;    // NOTE: Expects the channel number (not zero-based)
	DMX_CHANNELS_SPLIT_HIGH             = 3;    // NOTE: Expects the channel number (not zero-based)
	DMX_MULTICAST_CHANNELS_SPLIT_LOW    = 4;    // NOTE: Expects the channel INDEX to start from, as it takes into account the start address set from Spektra
	DMX_MULTICAST_CHANNELS_SPLIT_HIGH   = 5;    // NOTE: Expects the channel INDEX to start from, as it takes into account the start address set from Spektra
	DMX_BROADCAST                       = 6;    // Affects all DMX lights as per the Spektra Settings (number of lights and channels per light)
	DIDIO                               = 7;    // DEPRECATED
	FADE_UP_WITH_MIN                    = 8;    // DALI Fade Up Command - Query level and set Minimum if Off
	LIST_START                          = 9;    // Start a List action once
	LIST_START_CONTINUOUS               = 10;   // Start a List action with repeat 
	LIST_STOP                           = 11;   // Stop a List
	SPEKTRA_START_SEQ                   = 12;   // Start a Spektra Sequence
	SPEKTRA_STOP_SEQ                    = 13;   // Stop a playing Spektra Sequence
	SPEKTRA_THEME                       = 14;   // Apply a Spektra Theme
	SPEKTRA_STATIC                      = 15;   // DEPRECATED
	SPEKTRA_SCHEDULE                    = 16;   // Start the scheduled Spektra item
	LINK_START                          = 17;   // Enables the UDP Link State - If Configured
	LINK_STOP                           = 18;   // Temporarily disables the UDP Link State
	DISABLE_BURN                        = 19;   // Disable Burn-In
	ENABLE_BURN                         = 20;   // Enable Burn-In
	ON_OFF_TOG                          = 21;   // Turn a Group/Addres On/Off based on query level. If DALI_GROUP_ALL, toggle based on flag
	MIN_MAX_TOG                         = 22;   // On/Off Toggle replaced by Min/Max
	ENABLE_INPUT                        = 23;   // Enable Input - If latching, Input will trigger immediatly
	DISABLE_INPUT                       = 24;   // Disable Input
	ENABLE_TOG_INPUT                    = 25;   // Toggle Enable/Disable Input
	OUTPUT_TOG                          = 26;   // Toggle Output State between High (~22Vdc) and Low (0Vdc)
	OUTPUT_HIGH                         = 27;   // Set Output HIGH
	OUTPUT_LOW                          = 28;   // Set Output LOW
	OUTPUT_TRIG                         = 29;   // Set Output to trigger momentarily based on configuration
	PROFILE_CHANGE                      = 30;   // Change Profile - This action will reset sensor state
	FADE_LONG_PRESS                     = 31;   // Long Press Fade based on Toggle Flag
	SYNCRO                              = 32;   // Command sets clock to 11:59PM. Used for hardware time update by external Timeclock
	PRESET_CODE                         = 33;   // Preset Code - See Configurator Description
	CUSTOM_CODE                         = 34;   // Project Specific Custom Code - Talk to Creative Lighting for support
    SPEKTRA_SLEEP                       = 35;   // Pause Spektra sequence
    SPEKTRA_RESUME                      = 36;   // Resume Spektra sequence
	DEVICE_RESET						= 37;   // Admin Command for Hardware Reset
	DEVICE_SAVE							= 38;   // Admin Command for manual device memory save
    USER_LEVEL_STORE_NEW                = 39;   // Store Current Level to Variable
    USER_LEVEL_SET_DEFAULT              = 40;   // Reset User Level Variable
    USER_LEVEL_RECALL                   = 41;   // Recall User Level Variable
    ROOM_JOIN                           = 43;   // DEPRECATED
    ROOM_UNJOIN                         = 44;   // DEPRECATED
	TYPE8_TC_WARMER					    = 45;   // DALI Type 8 Warmer Command. 1 Mirek increments
	TYPE8_TC_COOLER					    = 46;   // DALI Type 8 Cooler Command. 1 Mirek increments
	TYPE8_TC_ACTUAL					    = 47;   // DALI Type 8 Set Colour to Mirek value
	LOGIC_OPERATION                     = 48;   // Not Implemented
	ALARM_ENABLE						= 49;   // Enable Alarm at Index
	ALARM_DISABLE						= 50;   // Disable Alarm at Index
	DALI_CONTROL_SENSOR_OVERRIDE        = 51;	// Puts the DALI Sensor in 'override mode', which means it will no longer control the lighting until occupancy has timed-out or control is manually resumed
	DALI_CONTROL_SENSOR_TEMP_DISABLE    = 52;	// Sets the occupancy timer to zero and puts the DALI Sensor in a temporary 'disable mode' (duration depends on Sensor configuration: 'Disable Period')
	DALI_CONTROL_SENSOR_RESUME          = 53;	// Takes the DALI Sensor out of 'override mode'
	DALI_ARC_OVERRIDE                   = 54;	// For controlling DALI Arc Levels (0 to 254) and 255 for MASK - Sets associated group to override mode
	DALI_COMMAND_OVERRIDE               = 55;   // For sending DALI commands - Sets associated group to override mode
    FADE_UP_WITH_MIN_OVERRIDE           = 56;   // Non-native DALI command override (sets associated group to override mode)
    ON_OFF_TOG_OVERRIDE                 = 57;   // Non-native DALI command override (sets associated group to override mode)
    MIN_MAX_TOG_OVERRIDE                = 58;   // Non-native DALI command override (sets associated group to override mode)
    MAX_OFF_TOG                         = 59;   // Not Implemented
    MAX_OFF_TOG_OVERRIDE                = 60;   // Not Implemented
    FADE_LONG_PRESS_OVERRIDE            = 61;   // Non-native DALI command override (sets associated group to override mode)
    USER_LEVEL_RECALL_OVERRIDE          = 62;   // Non-native DALI command override (sets associated group to override mode)
	DMX_ZONE_FADE_UP					= 63;   // DMX Spektra Zone Fade UP
	DMX_ZONE_FADE_DOWN					= 64;   // DMX Spektra Zone Fade DOWN
	LOGGING_LEVEL						= 65;	// Enable Logging to EEPROM to be read by configurator
    SPEKTRA_SHOW_CONTROL                = 66;   // DEPRECATED
    CIRCADIAN_TEMPERATURE               = 67;   // Selects Colour Temperature based on clock
    DALI_CONTROL_SENSOR_MUTE            = 68;   // Mute Sensor at Index (or all with Index 255)
    DALI_CONTROL_SENSOR_UNMUTE          = 69;   // Unmute to Sensor at Index (or all with Index 255)
    SPEKTRA_INTENSITY                   = 70;   // Allow you to specify the maximum Spektra Sequence or Theme output intensity (10 to 100)%
    ENABLE_INPUT_NO_ACTION              = 71;   // Allow you to enable an input (Latching), but not trigger the action.
    SET_DALI_FADE_TIME                  = 72;   // Sets the DALI Fade Time
    NO_COMMAND                          = 254;  // This TriggerType should always be at the bottom of the list. Add any new TriggerTypes above it (up to 253).

}

enum ReadType {
    INPUTS                  = 0;
    OUTPUTS                 = 1;
    IR                      = 2;
    SENSOR                  = 3;
    // DEPRECATED: SENSORS  (4)
    LIST                    = 5;
    // DEPRECATED: LISTS    (6)
    ALARMS                  = 7;
    BURN_IN                 = 8;
    PROJECT                 = 9;
    NETWORK                 = 10;
    DEVICE                  = 11;
    POLL_DATA               = 12;
    LIST_EXTENDED           = 13;
	LOGIC	                = 14;
	DALI_INPUTS             = 15;
}

enum AlarmRepeatType {
    ALARM_NO_REPEAT         = 0;
    ALARM_REPEAT_DAILY      = 1;
    ALARM_REPEAT_WORK_DAY   = 2;
    ALARM_REPEAT_WEEKLY     = 3;
    ALARM_REPEAT_MONTHLY    = 4;
}

enum AlarmAstroType {
    ALARM_NO_ASTRO  = 0;
    ALARM_SUNRUSE   = 1;
    ALARM_SUNSET    = 2;
}

enum SpektraTargetType {
    SETTINGS        = 0;
    SEQUENCE        = 1;
    THEME           = 2;
    STATIC          = 3;        // DEPRECATED
	CALENDAR        = 4;
    SHOW            = 5;        // DEPRECATED
    LIVE            = 6;        // Live Update of the Spektra settings
}

enum SpektraActionType {
    START  = 0;
    STOP   = 1;
    PAUSE  = 2;
    SAVE   = 3;
}

enum SpektraStepActionType {
    RUN_SEQUENCE    = 0;
    SHOW_THEME      = 1;
    START_LIST      = 2;
    PAUSE_PREVIOUS  = 3;
    STOP_PREVIOUS   = 4;
}

enum SpektraUnscheduledBehaviourType {
    RUN_RANDOM_COLOURED_SEQUENCE    = 0;   // Unless otherwise specified, this is a rotate sequence with random colours rotating every 5 seconds
    RUN_SEQUENCE_1                  = 1;   // Can be used to set a 'Default Sequence' with a known pattern and colour combination
    RESUME_PREVIOUS                 = 2;   // Resume the last Sequence or Theme that Spektra had active
    RUN_THEME_1                     = 3;   // Resume to Theme 1
    RUN_SHOW_1                      = 4;   // Resume to Show 1 
    DO_NOTHING                      = 254; // Left as the last possible type, fill between 0 and 253 as necessary
}

enum LineAddressingType {
    INDEPENDENT = 0;    // Control Lines are independently adddressed (e.g. DMX 1 to 512 per line)
    CONSECUTIVE = 1;    // Control Lines are consecutively addressed (e.g. DMX 1 to 512 on the first line, 513 to 1024 on the next, etc.)
}

enum AckMessageType {
    DECODE_FAILED                  = 0;  // May indicate an issue with the protocol (e.g. a mismatch in expected fields between clients). Ensure both parties are using the latest version.
    INDEX_OUT_OF_BOUNDS            = 1;  // A resource was requested beyond the amount available.
    UNEXPECTED_TYPE                = 2;  // The provided message was not able to be handled or processed (likely due to a lack of enough information or incorrect values).
    ENCODE_FAILED                  = 3;  // Not currently in use.
    KEY_MISMATCH                   = 4;  // Not currently in use.
    SUCCESS                        = 5;  // The message was decoded and handled successfully.
    INVALID_PARAMS                 = 6;  // The message was decoded but had invalid data for the intended outcome.
    UNEXPECTED_COMMAND             = 7;  // The message was decoded but the requested action was not valid for current the state of the device.
    COMMUNICATION_FAILED           = 8;  // The message could not be received or sent due to an internal issue.
    COMMUNICATION_TIMEOUT          = 9;  // May indicate contention for a shared resource or that an existing task is taking longer than expected and the latest request has timed-out.
    DATA_TOO_LONG                  = 10; // May indicate too much data was in the request or the required reply would be too big to handle.
    UNEXPECTED_CASE                = 11; // May indicate that the message is out of context (e.g. an "end" command for a process that is not running) or that the message requests a feature that is not yet implemented.
    SLOTS_FULL                     = 12; // Typically indicates that a request was valid, but the relevant content is "full" and thus elements must be removed before continuing.
    UNAUTHORISED                   = 13; // The message could not be actioned because the connection has not been authorised.
    PARTIAL_SUCCESS                = 14; // Can be returned in the case where some but not all Lines in a line_mask successfully sent
    COMMAND_FAILED                 = 15; // For whatever reason, the intended command did not complete
    DEPRECATED                     = 16; // For message which is no longer supported by this Firmware
}

// Standard DALI Type 8 Commands - See DALI Standard
enum Type8CommandType {
    SET_TEMP_X_COORD                     = 0;   
    SET_TEMP_Y_COORD                     = 1;
    ACTIVATE                             = 2;
    X_COORD_STEP_UP                      = 3;   // Activate Not Required
    X_COORD_STEP_DOWN                    = 4;   // Activate Not Required
    Y_COORD_STEP_UP                      = 5;   // Activate Not Required
    Y_COORD_STEP_DOWN                    = 6;   // Activate Not Required
    SET_TEMP_COLOUR_TEMPERATURE          = 7;   // DTR1 | DTR as Mirek Value
    COLOUR_TEMPERATURE_STEP_COOLER       = 8;   // Activate Not Required
    COLOUR_TEMPERATURE_STEP_WARMER       = 9;   // Activate Not Required
    SET_TEMP_PRI_N_DIMLEVEL              = 10;
    SET_TEMP_RGB_DIMLEVEL                = 11;
    SET_TEMP_WAF_DIMLEVEL                = 12;
    SET_TEMP_RGBWAF_CONTROL              = 13;
    COPY_REPORT_TEMPORARY                = 14;
    STORE_TY_PRI_N                       = 16;
    STORE_XY_COORD_PRI_N                 = 17;
    STORE_COLOUR_TEMPERATURE_LIMIT       = 18;
    STORE_GEAR_FEATURES_STATUS           = 19;
    ASSIGN_COLOR_LINKED_CH               = 21;
    START_AUTO_CAL                       = 22;
    ENABLE_DEVICE_TYPE8                  = 48; 
    SET_XY_COORDINATE                    = 50;  // Manufacturer Specific combined XY command
}

// Standard DALI Type 8 Queries - See DALI Standard
enum Type8QueryType {
    TYPE8_QUERY_NULL                  = 0; // Required as the first "default" element for the Protocol. Will not perform any action.
    TYPE8_QUERY_GEAR_FEATURES_STATUS  = 1;        // 247
    TYPE8_QUERY_COLOUR_STATUS         = 2;        // 248
    TYPE8_QUERY_COLOUR_TYPE_FEATURES  = 3;        // 249
    TYPE8_QUERY_COLOUR_VALUE          = 4;        // 250
    TYPE8_QUERY_RGBWAF_CONTROL        = 5;        // 251
    TYPE8_QUERY_ASSIGNED_COLOUR       = 6;        // 252
    TYPE8_QUERY_EXT_VERSION_NUM       = 8;        // 254
}

// Standard DALI 24 Bit Commands - See DALI Standard
enum DALI24DeviceSetting {
    COMMAND_IDENTIFY					= 0x00;
    COMMAND_RESET_POWER_CYCLE_SEEN		= 0x01;
    COMMAND_RESET						= 0x10;
    COMMAND_RESET_MEMORY_BANK			= 0x11;
    COMMAND_SET_SHORT_ADDRESS			= 0x14;
    COMMAND_ENABLE_WRITE_MEMORY			= 0x15;
    COMMAND_ENABLE_APP_CONTROLLER		= 0x16;
    COMMAND_DISABLE_APP_CONTROLLER		= 0x17;
    COMMAND_SET_OPERATING_MODE			= 0x18;
    COMMAND_ADD_TO_DEVICE_GROUPS_0_15	= 0x19;
    COMMAND_ADD_TO_DEVICE_GROUPS_15_32	= 0x1A;
    COMMAND_REMOVE_FROM_GROUPS_0_15		= 0x1B;
    COMMAND_REMOVE_FROM_GROUPS_16_32	= 0x1C;
    COMMAND_START_QUIESCENT_MODE		= 0x1D;
    COMMAND_STOP_QUIESCENT_MODE			= 0x1E;
    COMMAND_ENABLE_POWER_CYCLE_NOTIF	= 0x1F;
    COMMAND_DISABLE_POWER_CYCLE_NOTIF	= 0x20;
    COMMAND_SAVE_PERSISTENT_VARIABLES	= 0x21;
    SET_EVENT_PRIORITY					= 0x61;
    ENABLE_INSTANCE						= 0x62;
    DISABLE_INSTANCE					= 0x63;
    SET_PRIMARY_INSTANCE_GROUP			= 0x64;
    SET_INSTANCE_GROUP_1				= 0x65;
    SET_INSTANCE_GROUP_2				= 0x66;
    SET_EVENT_SCHEME					= 0x67;
    SET_EVENT_FILTER					= 0x68;
}

// Standard DALI 24 Bit Instance Types - See DALI Standard
enum DALI24InstanceType {
    DEFAULT				= 0x00;
    INPUT				= 0x01;
    ROTARY_INPUT        = 0x02;
    MOTION_SENSOR 		= 0x03;
    LIGHT_SENSOR	    = 0x04;
}

// Standard DALI 24 Bit Device Op Codes - See DALI Standard
enum DALI24OpCode {
    OPCODE_NULL				                    = 0x00; // No Action
    // Motion Sensor
    SENSOR_MOTION_SET_HOLD_TIMER				= 0x21;
    SENSOR_MOTION_SET_REPORT_TIMER				= 0x22;
    SENSOR_MOTION_SET_DEADTIME_TIMER			= 0x23;
    SENSOR_MOTION_CANCEL_HOLD_TIMER				= 0x24;

    // Light Sensor
    SENSOR_LIGHT_SET_REPORT_TIMER				= 0x30;
    SENSOR_LIGHT_SET_HYSTERESIS					= 0x31;
    SENSOR_LIGHT_SET_DEADTIME_TIMER				= 0x32;
    SENSOR_LIGHT_SET_HYSTERESIS_MIN				= 0x33;
}

enum LineType {
    LINE_EMPTY  = 0; // No Hardware in this slot
    LINE_DALI   = 1; // Physical DALI Board in this slot
    LINE_DMX    = 2; // Physical DMX Board in this slot
	LINE_DMX_IN = 3; // Physical DMX Board in this slot - Must be set in the case of DMX to DALI Translation.
    LINE_AUTO   = 4; // Line will be determined from physical hardware - Do not use for DMX to DALI Translation
}

enum EventType {
    REGISTER                = 0; // Sent by the client to register for events.
    TRIGGER_EVENT           = 1; // Emitted when trigger runs an action listed in TriggerType.
    INPUT_EVENT             = 2; // Emitted when a physical Input is triggered.
    SENSOR_EVENT            = 3; // Emitted when a Sensor (24-bit DALI or 25-bit Tridonic) is triggered.
    CONTROL_EVENT           = 4; // Emitted when an DALI/DMX/phyiscal output type event is done. References an action in TriggerType.
    ROOM_JOIN_EVENT         = 5; // Emitted when rooms are joined/unjoined.
    DALI_24_INPUT_EVENT     = 6; // Emitted when a 24-bit DALI Input Device is triggered.
    DALI_24_FRAME_EVENT     = 7; // Emitted when a 24-bit DALI Frame is received.
}

// Standard DALI Queries - See DALI Standard
enum DALIQueryType {
    DALI_QUERY_NULL                         = 0; // Required as the first "default" element for the Protocol. Will not perform any action.
    DALI_QUERY_STATUS                       = 144;
    DALI_QUERY_BALLAST                      = 145;
    DALI_QUERY_LAMP_FAILURE                 = 146;
    DALI_QUERY_LAMP_POWER_ON                = 147;
    DALI_QUERY_LIMIT_ERROR                  = 148;
    DALI_QUERY_RESET_STATE                  = 149;
    DALI_QUERY_MISSING_SHORT_ADDRESS        = 150;
    DALI_QUERY_VERSION_NUMBER               = 151;
    DALI_QUERY_DTR0                         = 152;
    DALI_QUERY_DEVICE_TYPE                  = 153;
    DALI_QUERY_PHYSICAL_MIN                 = 154;
    DALI_QUERY_POWER_FAILURE                = 155;
    DALI_QUERY_DTR1                         = 156;
    DALI_QUERY_DTR2                         = 157;
    DALI_QUERY_OPERATING_MODE               = 158;
    DALI_QUERY_LIGHTSOURCE_TYPE             = 159;
    DALI_QUERY_ACTUAL_LEVEL                 = 160;
    DALI_QUERY_MAX_LEVEL                    = 161;
    DALI_QUERY_MIN_LEVEL                    = 162;
    DALI_QUERY_POWER_ON_LEVEL               = 163;
    DALI_QUERY_SYSTEM_FAILURE_LEVEL         = 164;
    DALI_QUERY_FADETIME_FADERATE            = 165;
    DALI_QUERY_MANUFACTURER_SPECIFIC_MODE   = 166;
    DALI_QUERY_NEXT_DEVICE_TYPE             = 167;
    DALI_QUERY_EXTENDED_FADE_TIME           = 168;
    DALI_QUERY_CONTROL_GEAR_FAILURE         = 170;
    DALI_QUERY_SCENE_X_LEVEL                = 176;
    DALI_QUERY_GROUPS_0_7                   = 192;
    DALI_QUERY_GROUPS_8_15                  = 193;
    DALI_QUERY_RANDOM_ADDRESS_H             = 194;
    DALI_QUERY_RANDOM_ADDRESS_M             = 195;
    DALI_QUERY_RANDOM_ADDRESS_L             = 196;
    DALI_QUERY_READ_DTR_0_1                 = 197;
    DALI_QUERY_APP_EXT_COMMANDS             = 224;
    DALI_QUERY_EXT_VERSION_NUMBER           = 255;
    DALI_QUERY_COMPARE                      = 260;
    DALI_QUERY_VERIFY_SHORT_ADDRESS         = 268;
    DALI_QUERY_SHORT_ADDRESS                = 269;
}

// Standard DALI Commands - See DALI Standard
enum DALICommandType {
    DALI_OFF                       = 0;
    DALI_FADE_UP                   = 1;
    DALI_FADE_DOWN                 = 2;
    DALI_STEP_UP                   = 3;
    DALI_STEP_DOWN                 = 4;
    DALI_MAX_LEVEL                 = 5;
    DALI_MIN_LEVEL                 = 6;
    DALI_STEP_DOWN_OFF             = 7;
    DALI_ON_STEP_UP                = 8;
    DALI_ENABLE_DAPC_SEQ           = 9; 
    DALI_RECALL_LAST_ACTIVE_LEVEL  = 10;
    DALI_CONTINUOUS_UP             = 11;
    DALI_CONTINUOUS_DOWN           = 12;
    DALI_RECALL_SCENE_0            = 16;
    DALI_RECALL_SCENE_1            = 17;
    DALI_RECALL_SCENE_2            = 18;
    DALI_RECALL_SCENE_3            = 19;
    DALI_RECALL_SCENE_4            = 20;
    DALI_RECALL_SCENE_5            = 21;
    DALI_RECALL_SCENE_6            = 22;
    DALI_RECALL_SCENE_7            = 23;
    DALI_RECALL_SCENE_8            = 24;
    DALI_RECALL_SCENE_9            = 25;
    DALI_RECALL_SCENE_10           = 26;
    DALI_RECALL_SCENE_11           = 27;
    DALI_RECALL_SCENE_12           = 28;
    DALI_RECALL_SCENE_13           = 29;
    DALI_RECALL_SCENE_14           = 30;
    DALI_RECALL_SCENE_15           = 31;
    DALI_RESET                     = 32;
    DALI_STORE_ACTUAL_LEVEL_DTR0   = 33;
    DALI_SAVE_PERSISTENT_VARS      = 34;
    DALI_SET_OPERATING_MODE        = 35;
    DALI_RESET_MEMORY_BANK         = 36;
    DALI_IDENTIFY_DEVICE           = 37;
    DALI_SET_MAX_LEVEL             = 42;
    DALI_SET_MIN_LEVEL             = 43;
    DALI_SET_SYSTEM_FAILURE_LEVEL  = 44;
    DALI_SET_POWER_ON_LEVEL        = 45;
    DALI_SET_FADE_TIME             = 46;
    DALI_SET_FADE_RATE             = 47;
    DALI_SET_EXT_FADE_TIME         = 48;
    DALI_SET_SCENE_0               = 64;
    DALI_SET_SCENE_1               = 65;
    DALI_SET_SCENE_2               = 66;
    DALI_SET_SCENE_3               = 67;
    DALI_SET_SCENE_4               = 68;
    DALI_SET_SCENE_5               = 69;
    DALI_SET_SCENE_6               = 70;
    DALI_SET_SCENE_7               = 71;
    DALI_SET_SCENE_8               = 72;
    DALI_SET_SCENE_9               = 73;
    DALI_SET_SCENE_10              = 74;
    DALI_SET_SCENE_11              = 75;
    DALI_SET_SCENE_12              = 76;
    DALI_SET_SCENE_13              = 77;
    DALI_SET_SCENE_14              = 78;
    DALI_SET_SCENE_15              = 79;
    DALI_REMOVE_FROM_SCENE_0       = 80;
    DALI_REMOVE_FROM_SCENE_1       = 81;
    DALI_REMOVE_FROM_SCENE_2       = 82;
    DALI_REMOVE_FROM_SCENE_3       = 83;
    DALI_REMOVE_FROM_SCENE_4       = 84;
    DALI_REMOVE_FROM_SCENE_5       = 85;
    DALI_REMOVE_FROM_SCENE_6       = 86;
    DALI_REMOVE_FROM_SCENE_7       = 87;
    DALI_REMOVE_FROM_SCENE_8       = 88;
    DALI_REMOVE_FROM_SCENE_9       = 89;
    DALI_REMOVE_FROM_SCENE_10      = 90;
    DALI_REMOVE_FROM_SCENE_11      = 91;
    DALI_REMOVE_FROM_SCENE_12      = 92;
    DALI_REMOVE_FROM_SCENE_13      = 93;
    DALI_REMOVE_FROM_SCENE_14      = 94;
    DALI_REMOVE_FROM_SCENE_15      = 95;
    DALI_ADD_TO_GROUP_0            = 96;
    DALI_ADD_TO_GROUP_1            = 97;
    DALI_ADD_TO_GROUP_2            = 98;
    DALI_ADD_TO_GROUP_3            = 99;
    DALI_ADD_TO_GROUP_4            = 100;
    DALI_ADD_TO_GROUP_5            = 101;
    DALI_ADD_TO_GROUP_6            = 102;
    DALI_ADD_TO_GROUP_7            = 103;
    DALI_ADD_TO_GROUP_8            = 104;
    DALI_ADD_TO_GROUP_9            = 105;
    DALI_ADD_TO_GROUP_10           = 106;
    DALI_ADD_TO_GROUP_11           = 107;
    DALI_ADD_TO_GROUP_12           = 108;
    DALI_ADD_TO_GROUP_13           = 109;
    DALI_ADD_TO_GROUP_14           = 110;
    DALI_ADD_TO_GROUP_15           = 111;
    DALI_REMOVE_FROM_GROUP_0       = 112;
    DALI_REMOVE_FROM_GROUP_1       = 113;
    DALI_REMOVE_FROM_GROUP_2       = 114;
    DALI_REMOVE_FROM_GROUP_3       = 115;
    DALI_REMOVE_FROM_GROUP_4       = 116;
    DALI_REMOVE_FROM_GROUP_5       = 117;
    DALI_REMOVE_FROM_GROUP_6       = 118;
    DALI_REMOVE_FROM_GROUP_7       = 119;
    DALI_REMOVE_FROM_GROUP_8       = 120;
    DALI_REMOVE_FROM_GROUP_9       = 121;
    DALI_REMOVE_FROM_GROUP_10      = 122;
    DALI_REMOVE_FROM_GROUP_11      = 123;
    DALI_REMOVE_FROM_GROUP_12      = 124;
    DALI_REMOVE_FROM_GROUP_13      = 125;
    DALI_REMOVE_FROM_GROUP_14      = 126;
    DALI_REMOVE_FROM_GROUP_15      = 127;
    DALI_SET_SHORT_ADDRESS         = 128;
    DALI_ENABLE_WRITE_MEMORY       = 129;
    DALI_TERMINATE                 = 255;
    DALI_INITIALISE                = 258;
    DALI_RANDOMISE                 = 259;
    DALI_WITHDRAW                  = 261;
    DALI_SEARCH_ADDR_H             = 264;
    DALI_SEARCH_ADDR_M             = 265;
    DALI_SEARCH_ADDR_L             = 266;
    DALI_PROGRAM_SHORT_ADDRESS     = 267;
}

// Non-native DALI Commands provided as quality-of-life functions.
enum CustomDALICommandType {
    DALI_ARC_LEVEL                 = 0; // DALI Arc level (0 - 254)
    DALI_DAPC_LEVEL                = 1; // Runs a DALI_ENABLE_DAPC_SEQUENCE if needed.          // DEPRECATED
    DALI_GROUP_ARC_LEVEL           = 2; // Specified by Group ID (0 - 15)                       // DEPRECATED
    DALI_BROADCAST_SCENE           = 3; // No specific Address required, sent to all Devices    // DEPRECATED
    DALI_SCENE_ON_GROUP            = 4; // Specified by Group ID (0 - 15)                       // DEPRECATED
    DALI_SCENE_ON_ADDRESS          = 5; // Specified by Address (0 - 63)                        // DEPRECATED
    DALI_QUERY_MULTI_TYPES         = 6; // Query multi-device types, returned as a bitmask
}

enum AdminPropertyType {
    DEVICE_NAME         = 0; // The device name that appears on the network. Limited to 16 characters.
    PROJECT_NAME        = 1; // Used for documentation. Limited to 32 characters.
    LONGITUDE           = 2; // Used for calculating astronomical sunrise / sunset.
    LATITUDE            = 3; // Used for calculating astronomical sunrise / sunset.
    LOCAL_UTC_OFFSET    = 4; // Used for calculating astronomical sunrise / sunset.
    DAYLIGHT_SAVINGS    = 5; // Used for calculating astronomical sunrise / sunset.
    POLL_ACTIVE         = 6; // Whether or not to poll the current level of DALI devices to keep an in-memory cache up-to-date.
    DHCP_ENABLED        = 7; // Whether or not the device should use a static IP or expect a DHCP server to provide it with an IP.
    IP_ADDR             = 8; // The static IP address to use if DHCP_ENABLED is FALSE.
    MAC_ADDR            = 9; // The MAC Address of the device. Expected format: [40:D8:55:1B:XX:XX]
    GATEWAY_IP          = 10; // The IP address of the gateway for the network this device will be installed on.
    NETWORK_PROPERTIES  = 11; // Contains numerous properties such as DHCP, NTP, Gateway, IP, MAC
    SYSTEM_PROPERTIES   = 12; // Contains numerous properties such as Device Name (documentation only; not network hostname), Project Name, Latitude, Longitude, UTC Offset, DLS, Polling
    CONTROLLER_LINES    = 13; // Allows you to specify the daughterboards installed in the device [NONE, DALI, DMX, DMX_IN]
    EEPROM_FULL_CHIP    = 14; // Allows you to request a reset to default values for all data stored in EEPROM
    CONFIG_DATA         = 15; // Allows you to request a reset to default values for the Config Data stored in EEPROM
    SPEKTRA_DATA        = 16; // Allows you to request a reset to default values for the Spektra Data stored in EEPROM
    DEVICE_STATUS       = 17; // Can be used to request the Device Status: Temperature and Battery Voltage
    CONFIG_STATUS       = 18; // Can be used to request the Config Status: Active Alarm, List States, Sensor States, Burn-in States
    DEVICE_TIME         = 19; // Get or Set the RTC time on the device
    NTP_DETAILS         = 20; // Allows you to Get or Set the NTP parameters (i.e. NTP Server) used for maintaining the RTC via NTP updates.
    DALI_SENSORS        = 21; // Provides actions for DALI Sensor control: "ADD" to un-mute all. "REMOVE" to mute all. "RESET" to clear all (unprogram).
    SECURE_SESSION      = 22; // Allows you to Get or Set the "Secure Session" status of the device
    NONCE               = 23; // Allows you to request a Nonce to perform a Secure Login
    DALI_SENSOR_TYPE    = 24; // The type of DALI frame (24 or 25-bit) for eDALI packets to/from motion sensors
    DEVICE_REBOOT       = 25; // Will reboot the device when used with the 'RUN' AdminCommandType
	SYSTEM_LOGGING      = 26; // Will reset the system logs when used with a 'RESET' AdminCommandType
    SUBNET              = 27; // The Subnet of the Device
    DNS                 = 28; // The Primary and Secondary DNS
    LINK                = 29; // Wheter or not the UDP Link state is active
    LINK_TYPE           = 30; // Type of Link to enable, based on ReadType
    LINK_MASK           = 31; // Link Index Mask for above
    LINK_NETMASK        = 32; // Netmask for Link to create Network groups for UDP messaging
}

// Used with AdminPropertyType
enum AdminCommandType {
    SET         = 0; // Set property
    GET         = 1; // Get property
    ADD         = 2; // Add property
    REMOVE      = 3; // Remove property
    RESET       = 4; // Reset property
    RUN         = 5; // Run property
}

// DALI status query response bitmask values - See DALI Standard
enum DALIStatusType {
    LAMP_OFF              = 0; // Not technically in DALI. But this is the default when mask = 0b00000000
    CONTROL_GEAR_FAILURE  = 1;
    LAMP_FAILURE          = 2;
    LAMP_ON               = 4;
    LIMIT_ERROR           = 8;
	// 
    FADE_RUNNING          = 16;
    RESET_STATE           = 32;
    SHORT_ADDRESS         = 64;
    POWER_CYCLE_SEEN      = 128;
}

// DALI Receive Flag 
enum DALIRXStatusFlag {
	WAITING                     = 0; // Internal Idle State - Should not be received
	RECEIVING_FRAME             = 1; // DALI Frame being Received
	NO_RECEIVED_FRAME           = 2; // Frame was recorded - Empty Data
	RECEIVED_8_BIT_FRAME        = 3; // Frame was recorded - 8 Bit Reply
	RECEIVED_16_BIT_FRAME       = 4; // Frame was recorded - 16 Bit - Standard Message
	RECEIVED_24_BIT_FRAME       = 5; // Frame was recorded - 24 Bit - eDALI Message
    RECEIVED_PARTIAL_FRAME      = 6; // Frame was recorded - Unusual Bit count
	IDLE                        = 7; // DALI System Idle
	CALIBRATION                 = 8; // Inhouse DALI Calibration
	ERROR_WHILE_SENDING         = 254; // Error while trying to Transmit DALI - Possibly no Bus Power
	ERROR_WHILE_RECEIVING       = 255; // Error while trying to Receive - Invalid Frame Data, or no response
}

enum DiagnosticMessageType {
    DIAGNOSTIC_SYSTEM_INFO   = 0; // Can be used to retrieve a large number of properties that describe the capabilities of the device. (Number of supported Lists, Alarms, etc.).
    DIAGNOSTIC_INPUT_STATUS  = 1; // Not currently supported (will default to SYSTEM_INFO).
    DALI_LEVEL_CACHE         = 2; // Can be used to retrieve the current entries of the in-memory DALI values cache.
    DMX_LEVEL_CACHE          = 3; // Can be used to retrieve the current entries of the in-memory DMX levels cache. Results must be paginated due to size of DMX universe (512).
    ROOM_JOINS               = 4; // DEPRECATED - Can be used to manipulate the "Joined Rooms" state.
    DALI_STATUS_CACHE        = 5; // Can be used to retrieve the current entries of the in-memory DALI status cache.
}

enum FirmwareCommandType {
	FW_READY           = 0; // System Ready for Firmware Message
	FW_APPLY           = 1; // Sent to controller to initiaite a Firmware update
	FW_VERIFY          = 2; // Sent to controller to initaite stored Firmware verification - This will complete the firmware upload mode and unlock normal functionality. 
	FW_VERIFY_FAILED   = 3; // Received from controller - Issue with stored Firmware
	FW_VERIFY_SUCCESS  = 4; // Received from controller - Stored Firmware is Valid
	FW_READ            = 5; // Set to controller to request information for currently stored Firmware
    FW_CLONE           = 6; // Command to Clone Main FW to Backup. Using the firmware_is_backup flag will clone Backup to Main
}

enum SpektraTransitionType {
	BLEND           = 0;    // Blended colour transitions. Example: Transition between red and green will go through yellow.
    SNAP            = 1;    // Instant colour transitions.
    FADE_TO_BLACK   = 2;    // Example: Transition between red and green will fade the light off then on between colours. Not currently supported.
}

enum LogicType {
	DALI_LEVEL          = 0;
	INPUT_STATE         = 1;
	LIST_RUNNING        = 2;
	OCCUPANCY_DETECTED  = 3;
	DMX_PRESENT         = 4;
	CAL_WEEKDAY         = 5;
	CAL_MONTH           = 6;
	ALARM_SCHEDULED     = 7;
    DALI_CACHE_STATUS   = 8;        // Any DALI Error Status?
    HAS_ERROR           = 9;        // Target_index is error bitmask filter [LSB DALI Poll Error, DALI Line Error, Ethernet Link Dropped, Over Temperature, OLED Error, Spare, Spare, Spare MSB]
}

enum LogicComparisonType {
	LESS_THAN           = 0;
	LESS_THAN_OR_EQUALS = 1;
	EQUALS              = 2;
	MORE_THAN           = 3;
	MORE_THAN_OR_EQUALS = 4;
	NOT_EQUAL           = 5;
    BIT_OR              = 6;
    BIT_AND             = 7;
    BIT_XOR             = 8;
}

enum DALISensorType {
    TRIDONIC_EDALI    = 0; // Specific 25-bit frame type for Tridonic pre-configured MSensors
    STANDARD_EDALI    = 1; // Standard 24-bit 'eDALI' frames
}

enum SensorCommandType {
    INITIALISE  = 0; // Applies default settings to all Sensors (broadcast) and resets their detection state
    MUTE        = 1; // Stops a Sensor from sending DALI packets
    UNMUTE      = 2; // Allows a Sensor to send DALI packets
    OVERRIDE    = 3; // Puts a Sensor in 'Override Mode' which prevents it from adjusting the Light Level (until after the occupancy timeout occurs)
    IDENTIFY    = 4; // Starts the 'Identify' behaviour of a Sensor (typically this involves rapid flashing of the status LED for several seconds)
}

enum SystemLogType {
	BOOT        = 0;    // Power Action - System has booted
	NET_LINK    = 1;    // Network Link Achieved/Disconnected
	NTP         = 2;    // NTP Action
	TRIGGER     = 3;    // Trigger Action
	SPEKTRA     = 4;    // Spektra Action
	SCHEDULE    = 5;    // Alarm Action
	USER = 6;           // User has changed Log Level
}

enum DALI24InputType {
    MOMENTARY_SHORT     = 0;
    MOMENTARY_LONG      = 1;
    LATCHED_LOW         = 2;
    LATCHED_HIGH        = 3;
    POSITIONAL          = 4;
}

enum DALIMotionSensorStates {
    MOTION_IDLE        = 0;
    MOTION_DISABLED    = 1;
    MOTION_WARNING     = 2;
    MOTION_OCCUPANCY   = 3;
}

enum DALILuxSensorStates {
    LUX_DISABLED    = 0;
    LUX_ENABLED     = 1;
    LUX_DEVIATE     = 2;
}

/********** @exclude General Messages ****************/
// Sent in Response to another message.
message AckMessage {
    AckMessageType payload  = 1;    // Will either indicate 'Success' or a particular Error as specified by "AckMessageType"
}

// Contains a payload. Used in multiple message types. Incorrect payload type will result in AckMessage Unexpected Type.
message PayloadMessage {
    oneof data {
        uint32 uint_data     = 1; // Binary Flags set with 0 (FALSE) and 1 (TRUE)
        float float_data     = 2;
    }
    string string_data       = 3; // Every PayloadMessage will contain String data, with optional uint or float data
}

// "Are You There" Message with some supplementary values for debugging. "Are you there?" messages should be sent within 20 seconds to maintain a connection. However, any received message will reset this timer.
message AytMessage {
	uint32 timesinceboot    = 1;	// Device uptime in seconds
	float temperature       = 2;	// Current Temp on the device internals
	TimeClockMessage time   = 3;	// Current Time of the RTC
}

// This message contains the 'variable state' for the Device
message DeviceStateMessage {
    uint32 uptime                       = 1;    // Uptime (seconds since boot)
    float temp                          = 2;    // Temperature
    float vbat                          = 3;    // Battery voltage
    TimeClockMessage clock              = 4;    // RTC Time on device
    uint32 next_alarm                   = 5;    // Index of next alarm
    TimeClockMessage next_alarm_time    = 6;    // Time of next alarm
    uint32 input_state                  = 7;    // Input state mask
    repeated uint32 list_states         = 8;    // State of each List (DISABLED / ENABLED / LOOPING)
	repeated uint32 burn_in_states      = 9;    // State of each Burn-in (RUNNING / NOT RUNNING)
	repeated uint32 sensor_states       = 10;   // State of each DALI Sensor (IDLE / DISABLED / WARNING / OCCUPANCY)
    repeated uint32 zone_states         = 11;   // State of each Spektra Zone (OFF / SEQUENCE / THEME / STATIC)
    repeated uint32 zone_sleep_states   = 12;   // Sleep State of each Spektra Zone (TRUE / FALSE)
    repeated uint32 zone_indexes        = 13;   // Index of the selected Sequence, Theme, or Static colour for each Zone
	uint64 dali_input_state			    = 14;	// DALI Input state mask
    uint32 output_state                 = 15;   // Output state mask
}

/****** @exclude CONFIGURABLE MESSAGES ******/
// Trigger Message Structure. Stores all information for Trigger Type Actions
message TriggerMessage {
    TriggerType type     = 1; // The type of Trigger
    uint32 zone          = 2; // Which Zone (Spektra)
    uint32 line_mask     = 3; // Which Line(s) to perform this trigger on (if applicable)
    uint32 target_index  = 4; // Index to target (context depends on TriggerType)
    uint32 value         = 5; // Value for this trigger (if applicable)
    uint32 query_index   = 6; // Index to query (if applicable)
}

// Date/Time Message Structure. Year is 0-99. Month is 1 (Jan) - 12 (Dec), Date is day of the month, Day is Weekday with 1 (Monday) - 7 (Sunday)
message TimeClockMessage {
    uint32 date  = 1;    // Year | Month | Date | Day 
    uint32 time  = 2;    // <Empty> | Hour | Minute | Second
}

// Message to describe the two Burn-In objects
message BurnInBitsMessage {
    uint32 light_state   = 1; // Tracks when a Light is 'On' and "burning in"
    uint32 running_flag  = 2; // Whether or not the burn-in is currently counting down
    uint32 enable_flag   = 3; // Whether or not the burn-in should count down
}

// Message to describe the 12 or 24 Physical Inputs. Not sent natively, see InputMultiMessage
message IOInputMessage {
    uint32 index                       = 1; // Which Input is this (0 - 11) on 4 Pole and (0 - 23) on 9 Pole
    TriggerOperationType button_state  = 2; // How will this Input be triggered? Momentary (short/long press) or Latching (low/high)
    TriggerMessage short_press         = 3; // What action should occur on short/low
    TriggerMessage long_press          = 4; // What action should occur on long/high
}

// Message to describe the 4 or 8 Physical Outputs. Not sent natively, see OutputMultiMessage
message IOOutputMessage {
    uint32 index                    = 1; // Which Output is this? (0 - 3) on 4 Pole and (0 - 7) on 9 Pole. Note: Actual Pin numbers are (9 - 12) and (21 - 24) respectively.
    uint32 initial_level            = 2; // Will the Output be Low or High at startup?
    uint32 time_trigger_is_active   = 3; // How long should a 'Trigger Output' command last?
    TriggerOperationType type       = 4; // Is this a continuous (latching) trigger or momentary output?
}

// Message to describe the (Up to) 40 DALI 2 Input Devices. Not sent natively, see DALIInputMultiMessage
message DALIInputMessage {
    uint32 index                       = 1; // Which index for this Input
    uint32 address                     = 2; // The eDALI Address of this Input
    uint32 dali_line                   = 3; // The DALI Line this Input is on
    TriggerOperationType button_state  = 4; // How will this Input be triggered? Momentary (short/long press) or Latching (low/high)
    TriggerMessage short_press         = 5; // What action should occur on short/low
    TriggerMessage long_press          = 6; // What action should occur on long/high
    uint32 instance                    = 7; // What instance of the device? If it has multiple inputs
}

// Message to describe the Infrared Input (DEPRECATED)
message IOIRMessage {
    uint32 index           = 1;
    TriggerMessage action  = 2;
    uint32 codes           = 3;
}

// Message to describe the (Up to) 40 DALI 2 Sensors. Not sent natively, see SensorMultiMessage
message SensorMessage {
    uint32 profile                      = 1;  // Under which Profile is this Sensor active?
    uint32 index                        = 2;  // The index for this Sensor
    uint32 sensor_address               = 3;  // The eDALI Address of this Sensor (assumes address of "L" (Light) component with "M" (Motion) at L + 1)
    uint32 sensor_dali_line             = 4;  // The DALI Line this Sensor is on
    uint32 address_query                = 5;  // The DALI Address to query for Group-based control
    uint32 control_dali_line            = 6;  // The DALI Line (mask) to control
    uint32 control_group                = 7;  // The DALI Group Address to control
    uint32 light_setpoint               = 8;  // The Lux level to maintain during Daylight Harvesting
    uint32 warning_setpoint             = 9;  // The Arc level to set during the Warning Period
    uint32 motion_only                  = 10; // Is this Sensor used for motion detection only? If False, Daylight Harvesting will be in effect
    uint32 timeout_values               = 11; // How long after the last occupancy detection before the Sensor will activate the Warning Period
    uint32 warning_values               = 12; // How long after entering the Warning Period before the Sensor will activate the Disable Period
    uint32 disable_values               = 13; // How long after a complete timeout (after the Warning Period) should the Sensor wait before starting detection again?
    uint32 input_1_pm                   = 14; // DEPRECATED - The first Input button used for "Two-Button Programming"
    uint32 input_2_pm                   = 15; // DEPRECATED - The second Input button used for "Two-Button Programming:
    uint32 sensor_states                = 16; // Used to keep track of the Motion Sensor state
    uint32 motion_sensors               = 17; // A Bitmask of grouped Sensors
    uint32 lux_sensors                  = 18; // Used to keep track of the Light (Lux) Sensor state
    uint32 off_flag                     = 19; // Used to keep track of the Control Group's state
    bool is_programmed                  = 20; // Set to 'True' when the Firmware receives a SensorMessage with this Index
    TriggerMessage detection_trigger    = 21; // The action to perform upon initial detection
    TriggerMessage warning_trigger      = 22; // The action to perform upon transitioning to the Warning Period
    TriggerMessage idle_trigger         = 23; // The action to perform upon transitioning to the Idle (disable) Period
}

// List Step Structure for List Actions
message ListStepMessage {
    uint32 step_index      = 1; // Index of Step in List
    TriggerMessage action  = 2; // Action to perform
    uint32 time_seconds    = 3; // Time in seconds between steps, uint16_t value 
}

// Message to describe Scheduled Actions. Not sent natively, see AlarmMultiMessage
message AlarmMessage {
    uint32 index                    = 1; // Alarm Index from 0 - 9
    bool enabled                    = 2; // Enabled Flag - FALSE (0) or TRUE (1)
    TimeClockMessage start_time     = 3; // Time to Start Action, or Astro Offset
    TimeClockMessage end_time       = 4; // Time to Stop Action, or Astro Offset
    TriggerMessage start_trigger    = 5; // Trigger Action to perform at start time
    TriggerMessage end_trigger      = 6; // Trigger Action to perform at end time
    AlarmAstroType astro_start      = 7; // Start Time Type
    AlarmAstroType astro_end        = 8; // End Time Type
    AlarmRepeatType repeat          = 9; // Alarm Repeat Type
    uint32 repeat_day_bitmask       = 10; // 1 to trigger on this day. LSB (0) = Monday, MSB (6) = Sunday
    uint32 repeat_month_bitmask     = 11; // 1 to trigger during this month. LSB (0) = January, MSB (11) = December
    bool yearly                     = 12; // Should this Alarm happen each year?
    bool start_offset_is_before     = 13; // E.g. 10 minutes BEFORE or AFTER the start astro event?
    bool end_offset_is_before       = 14; // E.g. 10 minutes BEFORE or AFTER the end astro event?
}

// Message to describe the two Burn-In Actions. While Burn-In is active, the system will check associated DALI line and group and prevent any action other than 100% or 0%. Any value set over 1% will be forced to 100%. Not sent natively, see BurnInMultiMessage
message BurnInMessage {
    uint32 index              = 1;
    uint32 line               = 2;
    uint32 address            = 3;
    uint32 query_address      = 4;
    uint32 time               = 5;
    uint32 remaining          = 6;
    BurnInBitsMessage states  = 7;
}

// This message will allow an externally connected device to send a Trigger action
message ExternalTriggerMessage {
    TriggerMessage trigger  = 1; // Can be used to action Triggers via the network instead of via a hardware input or on-board alarm
}

// Message used to send all Physical Inputs, for a specific profile
message InputMultiMessage {
    uint32 profile                  = 1;
    repeated IOInputMessage inputs  = 2;     
}

// Message used to send all Outputs, for a specific profile
message OutputMultiMessage {
    uint32 profile                    = 1;
    repeated IOOutputMessage outputs  = 2;
}

// Message used to send all DALI Inputs, for a specific profile
message DALIInputMultiMessage {
	uint32 profile 					  = 1;
    uint32 input_index_offset         = 2; // To support paginated results (0-9, 10-19, 20-29, 30-39)
	repeated DALIInputMessage inputs  = 3;
}

// DEPRECATED
message IRMultiMessage {
    uint32 profile            = 1;
    repeated IOIRMessage irs  = 2;
}

// Message used to send a List. If more than 32 steps in the list, the ExtendedListMessage is used repeatedly to send the remainder.
message ListMessage {
    uint32 list_index              = 1;
    repeated ListStepMessage step  = 2; // Limited to 32 for this Message Type; you must use ExtendedListMessage to configure more than 32 steps per List
    uint32 list_state              = 3; // Typically will be 'DISABLED' to start with (requires a 'START LIST' trigger to begin)
    uint32 total_step_count        = 4; // Can be greater than 32, but you must use ExtendedListMessage to send the rest
}

// This Message must be used when the List has more than 32 steps
message ExtendedListMessage {
    uint32 list_index              = 1; // Which List do these steps belong to?
    uint32 step_index_offset       = 2; // 0 for the first ExtendedListMessage; offset by 32 for every ExtendedListMessage beyond the first
    repeated ListStepMessage step  = 3;
}

// Message used to send the Alarms
message AlarmMultiMessage {
    repeated AlarmMessage alarm  = 1;
}

// Message used to send the Burn-Ins
message BurnInMultiMessage {
    repeated BurnInMessage burnin  = 1;
}

// Not Currently Implemented
message LogicMessage {
	uint32 index                            = 1;
	bool enabled                            = 2;
	TriggerMessage comparison_object        = 3;		// What to compare??
	uint32 comparison_value                 = 4;		// Setpoint for comparison
	LogicComparisonType comparison_type     = 5;	    // Type to compare
	TriggerMessage actionA                  = 6;		// Action if True
	TriggerMessage actionB                  = 7;		// Action if False
}

// Not Currently Implemented
message LogicMultiMessage {
	repeated LogicMessage logic = 1;
}

/*********** @exclude SYSTEM MESSAGES *******/
// Message used to send specific sensor commands, such as Mute, Unmute and Override. Mute will stop the sensor from talking until; Unmute, Profile Change, or Program. Override will prevent the sensor from changing the currently selected level until it has timed-out
message SensorCommandMessage {
    uint32 command          = 1; // DEPRECATED: Use 'type' instead
    uint32 index            = 2;
    SensorCommandType type  = 3;
}

// Message used to change Profiles. Note that changing the profile will cause the sensors to reset
message ChangeProfileMessage {
    uint32 profile  = 1;
}

// Message used to show information on screen to aid with physical indentification
message IdentifyMessage {
    uint64 MAC  = 1;
    uint64 IP   = 2;
}

// Message to update the device time. Message will be affected by Day Light Savings (If selected) and will refresh currently selected schedules
message UpdateTimeMessage {
    TimeClockMessage time  = 1;
}

// Message used to request device information, such as inputs, lists, sensors, etc
message ReadDeviceMessage {
    uint32 profile  = 1;
    ReadType type   = 2;
    uint32 index    = 3;
    uint32 secondary_index = 4; // For more advanced reads (e.g. ExtendedListMessage)
}

// Message used to send a secure login settings message. AES Encryption Required
message SecureDeviceSettingsMessage {
    string payload   = 1; // Encrypted payload of a PB message.
}

/************ @exclude DALI MESSAGES ************/

// DALI DTR Message structure. 
message DTRPayloadMessage {
    repeated uint32 dtr = 1; // For DALI, you can use 2 bytes, for eDALI 3. Format - DTR0 | DTR1 << 8 | DTR2 << 16
}

// Message to send a DALI command using various DALI frame types.
message DALIMessage {
    uint32 line_mask                         = 1; // Binary mask; e.g. selecting line 1 out of 4 looks like 0b0001. For non queries, line_mask can contain multiple valid lines
    uint32 address                           = 2; // DALI Address
    oneof action {
        uint32 frame_25_bit                  = 3; // Older eDALI commmands are manufacturer specific, so we have to take a raw value.
        uint32 frame_25_bit_reply            = 4; // Older eDALI commands can have a reply.
        DALICommandType command              = 5;
        CustomDALICommandType custom_command = 6;
        DALIQueryType query                  = 7;
        Type8CommandType type8               = 8;
        uint32 frame_16_bit                  = 11; // Standard DALI Frame data - Don't use arg
        uint32 frame_16_bit_reply            = 12; // Standard DALI Frame data with reply - Don't use arg
        uint32 frame_24_bit                  = 13; // Standard 24 Bit DALI Frame data - Don't use arg
        uint32 frame_24_bit_reply            = 14; // Standard 24 Bit DALI Frame data with reply - Don't use arg
        Type8QueryType type8_reply           = 15; 
        DALI24DeviceSetting device24_setting = 16; // Settings for DALI 24 Bit Devices
    }
    oneof params {
        uint32 arg                           = 9;   // 'arg' rather than level for methods where you need a scene number. XY Command uses X << 16 | Y
        DTRPayloadMessage dtr                = 10;
    }
    DALI24InstanceType instance_type         = 17;  // Instance for 24 bit device - Commands are sent via Type
    DALI24OpCode op_code                     = 18;  // OpCode for 24 bit device
}

// Message reply for DALI Status Flag
message DALIStatusFlagMessage {
    repeated DALIStatusType flags  = 1;
}

// DALI Response is tagged with the line and DALI address. 
message DALIQueryResponse {
	// Depreciated Query Method
    oneof payload {
        DALIStatusFlagMessage status_flags  = 1;
        PayloadMessage data                 = 2;
    }
	// New Query Method
	DALIRXStatusFlag dali_flag              = 3;
	PayloadMessage response_data            = 4;
}

// DALI Response for Addressing Error
enum DALIAddressingError {
    NO_ERROR        = 0; // Device found and Addressed
    VERIFY          = 1; // Device was found, address was set, but verification failed
    SEARCH          = 2; // Device was found, issue with long address
    NO_NEW_DEVICE   = 3; // No device found
}

// DALI Addressing Type
enum DALIAddressingType {
    ADDRESS_NEW      = 0; // Only Address New devices which have their address set to MASK (255)
    READDRESS_ALL    = 1; // Address everything on the line (Standard or 24 bit) - USE CAREFULLY
}

// Message to invoke DALI Addressing
message DALIAddressingMessage {
    DALIAddressingType type     = 1;            // New or All       
    bool initialisation         = 2;            // First Address (TRUE) or Next Address (FALSE)
    uint32 line_mask            = 3;            // Line to Address - Must be singular
    bool is24Bit                = 4;            // 24 Bit DALI (TRUE) or Standard (FALSE)
    DALIAddressingError error   = 5;            // Response -> Error while Addressing
    uint32 index                = 6;            // Response -> Index of Set Address
}

// Message to invoke DALI remapping
message DALIRemappingMessage {
    uint32 from_address   = 1;  // DALI Address to change
    uint32 to_address     = 2;  // New address for device. If populated, this address will change to the from_address
    uint32 line_mask      = 3;  // Affected DALI Line
    bool is24Bit          = 4;  // 24 bit DALI (TRUE) or Standard (FALSE)
}

message DALIAddressableObject {
    uint32 line             = 1; // Which DALI Line is this Device on?
    uint32 address          = 2; // What is the Short Address of this Device?
}

message DALIIdentifyDuplicatesMessage {
    uint32 line_mask                                        = 1; // Which DALI Line(s) to check
    bool is24Bit                                            = 2; // Use 24-bit DALI (DALI v2) or standard 16-bit DALI if FALSE
    repeated DALIAddressableObject possible_duplicates      = 3; // A collection of DALI Devices which *may* be using duplicated Short Addresses
}

/************* @exclude DMX MESSAGES *************/
// Message to send DMX on requested DMX line(s)
message DMXMessage {
    uint32 zone                 = 1; // For Spektra (default of 0 is fine if not applicable)
    uint32 universe_mask        = 2; // Which DMX Universes to apply the values to. Specified as a binary mask. Can be sent to multiple.
    uint32 channel              = 3; // The actual channel number (not zero-based index)
    uint32 repeat               = 4; // The number of times to repeat the data given (e.g. start from DMX channel 30 and set the RGB channel values (levels) of the next 3 lights, so repeat would be 3 with 3 levels provided)
    repeated uint32 level       = 5;
    uint32 fade_time_by_10ms    = 6; // The DMX Fade Task runs every 10ms, so a value of 25 will fade over 250ms
}

/************** @exlclude RDM MESSAGES ************/
// Message to send a DMX command with/without a response (Getset)
message RDMMessage {
	uint32 universe_mask        = 1;    // Universe Mask - Must be a single universe.
	uint64 uid                  = 2;    // UID of device to send the message to. Can be Multi/Broadcast
	uint32 pid                  = 3;    // RDM PID - See Standard
	uint32 getset               = 4;    // Expects [DMX_RDM_GET_COMMAND = 0x20] or [DMX_RDM_SET_COMMAND = 0x30]
	uint32 datalength           = 5;    // Length of Data to send
	repeated uint32 data        = 6;    // Data
}

// RDM Response message - source UID, PID, datalength and data
message RDMResponseMessage {
	uint64 uid              = 1;    // UID of requested device
	uint32 pid              = 2;    // Message PID
	uint32 datalength       = 3;    // Length of Data to receive
	repeated uint32 data    = 4;    // Data
}

// RDM Discovery Message - Invokes Discovery with reply as RDMDiscoveryReplyMessage. isNext flag allows for more than 128 devices to be discovered in additional messages.
message RDMDiscoveryMessage {
    uint32 universe_mask = 1;       // Universe Mask - Must be a single universe
    bool isNext = 2;                // If true, RDM module will search for additional or 'next' 128 RDM devices. If false (empty), RDM module will re-init search for up to 128 devices
}

// RDM Discovery Reply with up to 128 devices
message RDMDiscoveryReplyMessage {
    uint32 discovery_count = 1;
    repeated uint64 uid = 2;
    uint32 error_code = 3;
}

/************ @exclude SPEKTRA    *************/
// Message for Spektra Setting Information
message SpektraSettingMessage {    
    uint32 zone                                                 = 1; // Determine Spektra zone from 0-9
    uint32 start_address                                        = 2; // DMX or DALI Start Address. Typically RED on the first fixture.
    uint32 line_or_universe_mask                                = 3; // Which DALI Line(s) or DMX Universe(s) to control
    uint32 protocol                                             = 4; // E.g. DMX or DALI
    uint32 number_of_lights                                     = 5; // Number of DALI or DMX fixtures connected. If more than available channels, the 'consecutive' option can be selected which will use multiple lines, starting from the first line specified above
    uint32 channels_per_light                                   = 6; // E.g. 4 for RGBW
    repeated uint32 channel_colours                             = 7; // What colour is assigned to each channel (e.g. Red, Green, etc.)
    SpektraUnscheduledBehaviourType unscheduled_behaviour       = 8; // 0 = Random colours rotate sequence, 1 = Run default sequence (seq 1)
	repeated uint32 channel_mapping                             = 9; // Channel mapping for DALI or future DMX virtual 'grouping'
    LineAddressingType line_addressing                          = 10; // Independent or Consecutive
	float zone_scale_factor										= 11; // Zone Scale Factor - Float 0 to 1.0f
}

// Spektra Colour Channel Config Structure
message SpektraColourConfigMessage {
    repeated uint32 channel_value = 1;  // Include as many values as there are channels, e.g. [0, 255, 0] would be Green for an RGB light (3 channel values)
}

// Spektra Sequence Configuration Message. Up to 144 sequences can be stored
message SpektraSequenceConfigMessage {
    uint32 index                                        = 1; // Index of sequence - 0 to 143
    uint32 type                                         = 2; // BLEND / SIMPLE CHASE / SHADOW CHASE / COMET / ROTATE / TWINKLE / BUILD-UP / CRASH / FIREWORKS
    SpektraTransitionType transition                    = 3; // BLEND / SNAP / FADE_TO_BLACK
    uint32 fade_time_by_10ms                            = 4; // Correlates to blend transitions
    uint32 time_per_colour                              = 5; // How long each colour should be shown
    uint32 time_per_colour_unit                         = 6; // MILLISECONDS / SECONDS / MINUTES / HOURS
    uint32 time_per_step                                = 7; // How long each sequence type 'animation' takes (e.g. speed of the chase)
    uint32 time_per_step_unit                           = 8; // MILLISECONDS / SECONDS / MINUTES / HOURS
    uint32 range                                        = 9; // 0 for all lights, any number above 0 will repeat in blocks of (TOTAL LIGHTS / RANGE)
    repeated uint64 colour                              = 10; // Deprecated (kept for backward compatability) -> Use "colours" instead
    uint32 is_randomised_type                           = 11; // Will randomly selected (from random_types_mask) one of the Sequence Types
    uint32 random_types_mask                            = 12; // A bitmask of Sequence Types
    uint32 is_reverse_direction                         = 13; // Animate the sequence in reverse light order
    uint32 is_cycle_direction                           = 14; // Animate the sequence in alternating light order from forward to reverse
    string title                                        = 15; // The name of the Sequence
    bool has_random_colour_order                        = 16; // Randomly pick the next colour out of the chosen colours
    repeated SpektraColourConfigMessage colours         = 17; // The colours used in the Sequence
	repeated uint32 args                                = 18; // Function specific arguments * 5
}

// Message to define Spektra Calendar message. Zone options available in SpektraSettingsMessage to define what will happen if no action is scheduled on a calendar day.
message SpektraCalendarMessage {
	SpektraTargetType type  = 1;	    // Spektra Type (e.g. Sequence or Theme)
	uint32 index            = 2;        // Index (i.e. which Sequence or Theme)
	repeated bool days      = 3;        // Boolean array to specify when this Target Index is active (up to the number of days in a year)
    bool isOverride         = 4;        // Boolean isOverride. If override, only run once
}

// Spektra Calendar Day Structure
message SpektraCalendarDayMessage {
    uint32 day_index        = 1;    // Index of this day (0 to 365, 366 days total)
    SpektraTargetType type  = 2;    // Spektra Type for this day (e.g. Sequence or Theme)
    uint32 target_index     = 3;    // Index of the specified Type (i.e. which Sequence or Theme)
    bool isOverride         = 4;    // Boolean isOverride. If override, only run once
}

// Message to handle Spektra Calendar Read - This is the reply message to the read request
message SpektraCalendarOverviewMessage {
    uint32 day_offset                           = 1;    // Offset to start counting days from (0 is the first day of the year)
    repeated SpektraCalendarDayMessage days     = 2;    // Schedule information for each day; supports up to 90 days per Message
}

// Message to define Spektra Theme. Up to 16 Themes
message SpektraThemeConfigMessage {
    uint32 index                                        = 1;
    repeated uint64 colour                              = 2; // Deprecated (kept for backward compatability) -> Use colours instead
    string title                                        = 3; // The name of the Theme
    repeated SpektraColourConfigMessage colours         = 4; // The colours used in the Theme (will repeat colours if less colours than lights)
}

// Message to request Spektra Data
message SpektraReadMessage {
    SpektraTargetType type  = 1;
    uint32 index            = 2;
}

// Message to control the Spektra Module
message SpektraControlMessage {
    SpektraTargetType type        = 1;  // Spektra Target Type - Sequence/Theme
    uint32 zone                   = 2;  // Zone (0 to 9) or Zones (255) to control
    uint32 index                  = 3;  // Index of Action. I.e. Sequence 5
    SpektraActionType action      = 4;  // Type of Action. Start/Resume/Stop
}

message SpektraLiveMessage {
    repeated SpektraTargetType type         = 1;    // Target Type Per Zone (Sequence/Theme etc)
    repeated uint32 index                   = 2;    // Target Index Per Zone
    repeated SpektraActionType action       = 3;    // Target Action Per Zone
    // RAM Data Settings                
    repeated uint32 step_index              = 4;    // Current Step
	repeated uint32 step_index_direction    = 5;    // Forwards/Backwards (If Cycling)
	repeated uint32 colour_index            = 6;    // Current State of Colour Index (Changes over time)
	repeated uint32 colour_range            = 7;    // Current State of Colour Range (Changes based on Sequence Step)
    repeated uint32 random_seq_type         = 8;    // Currently Active Random Sequence Type
    repeated bool zone_active               = 9;    // Flag to show if any channel in this zone is active
}

/************ @exclude TRANSLATION  *************/
// Structure to describe the DMX to DALI translation
message DMXTranslationObject {
    uint32 line_in               = 1; // DMX IN - Must configure line as DMX IN
    uint32 line_out              = 2; // DALI OUT
    uint32 dmx_start_address     = 3; // DMX Start Address
    uint32 channel_count         = 4; // DMX Count
    repeated uint32 dali_array   = 5; // DALI Addresses
    // DEPRECATED: repeated uint32 sent_levels (6)
    uint32 affected_input        = 7; // Bitmask of affected inputs
    bool blocking                = 8; // If TRUE (1), the inputs will be ignored if the internal DMX receiving flag is TRUE
    bool enabled                 = 9; // Translation object is enabled (1) or disabled (0)   
}

// Message to describe the DMX to DALI translation objects. For a 4 line controller, up to 3 objects can be created allowing for single/multi line translation to single/multi line out.
message DMXProtocolTranslation {
    repeated DMXTranslationObject object  = 1; // Typically 1 for a 4 Pole device but can be more for 9 Pole eDIDIO
}

/************ @exclude DIAGNOSTICS *************/
// Structure of Input state mask when InputStateResponse message is sent. 1 is HIGH, 0 is LOW. GPIO are configured as default HIGH. If not connected, a momentary input will return TRUE (1)
message InputStateMessage {
    bool use_mask = 1; // Reply with a mask rather than a list of active inputs.
}

// Message containing the InputStateMessage mask
message InputStateResponse {
    repeated uint32 inputs  = 1; // Contains Inputs that are Low (i.e. currently active)
    uint32 input_mask       = 2; // Usage is determined by "InputStateMessage: use_mask"
}

// Message that contains DALI polled levels. Levels are split into pages of 64 values
message LevelCacheResponse { // DALI/DMX agnostic.
    repeated uint32 levels  = 1; // Repeated Level array
    uint32 line             = 2; // Requested Line
    uint32 page             = 3; // Page of requested information
}

// Message to request system information. Contains vital information about connected devices configuration capabilities, as well as firmware and hardware version. 
message DiagnosticSystemInfoResponse {
    string firmware                = 1; // Firmware Version number
    string hardware                = 2; // Hardware Version number
    string error                   = 3; // Any populated Error message
    uint32 input_count             = 4; // Number of supported Inputs
    uint32 output_count            = 5; // Number of supported Outptus
    uint32 ir_count                = 6; // Number of supported IR codes
    uint32 list_step_count         = 7; // Number of supported List Steps
    uint32 list_count              = 8; // Number of supported Lists
    uint32 alarm_count             = 9; // Number of supported Alarms (Schedules)
    uint32 burnin_count            = 10; // Number of supported Burn-ins
    uint32 spektra_seq_count       = 11; // Number of supported Spektra Sequences
    uint32 spektra_seq_step_count  = 12; // Number of supported Spektra Sequence Steps
    uint32 spektra_theme_count     = 13; // Number of supported Spektra Themes
    uint32 spektra_static_count    = 14; // Number of supported Spektra Static Colours
    uint32 proto_version           = 15; // Protocol Buffer Version number
    uint32 line_count              = 16; // Number of supported Control Lines (for DMX, DALI)
    repeated LineType lines        = 17; // Denotes what control type is assigned to each line (e.g. DMX, DALI)
    uint32 profile_count           = 18; // Number of supported Profiles
    uint32 preset_code_count       = 19; // Number of supported Preset Codes
    uint32 user_level_count        = 20; // Number of supported User Levels
    uint32 dmx_to_dali_count       = 21; // Number of supported DMX to DALI Translations 
    uint32 spektra_zone_count      = 22; // Number of supported Spektra Zones
	uint32 logic_count			   = 23; // Number of supported Logic Mappings
	uint32 input_dali_count 	   = 24; // Number of supported DALI Inputs
    string vendor_id               = 25; // Vendor ID - "Control Freak"
    uint32 selected_profile        = 26; // Currently Selected Profile
}

// Request a diagnostic response message of a given type.
message DiagnosticMessage {
    DiagnosticMessageType type  = 1;
    uint32 page                 = 2; // Allow paging of results, eg. 32 DMX levels per page, 16 pages.
    uint32 line                 = 3; // If a line/DMX universe needs to be indicated it can go here.
}

/**************** @exclude ADMIN ***************/
// Message to get or set Admin Properties in reference to project information. 
message AdminProjectPropertiesMessage {
    string device_name              = 2; // As shown on the Network (in Spektra/Configurator Discovery)
    string project_name             = 3; // For project documentation
    float longitude                 = 4; // For astronomical calculations (e.g. sunrise/sunset)
    float latitude                  = 5; // For astronomical calculations (e.g. sunrise/sunset)
    float local_offset              = 6; // For astronomical calculations (e.g. sunrise/sunset)
    bool daylight_savings           = 7; // For astronomical calculations (e.g. sunrise/sunset)
	uint32 daylight_savings_start   = 8; // Can be used to state when DST is active from
	uint32 daylight_savings_end     = 9; // Can be used to state when DST is active to
    uint32 poll_active              = 10; // Should the device be polling the DALI line to cache arc levels. If not 0, it is the polling interval in seconds
}

// Message to get or set Admin Properties in reference to the device configuration
message AdminConfigStatusMessage {
	repeated uint32 list_status = 1;				// State of each List (DISABLED / ENABLED / LOOPING)
	repeated uint32 burn_in_status = 2;				// State of each Burn-in (RUNNING / NOT RUNNING)
	uint32 alarm_status = 3;						// Currently Selected Alarm (i.e. 'next Alarm')
	TimeClockMessage alarm_time_from_reg = 4;		// Time for next Alarm as per RTC Register
	repeated uint32 sensor_status = 5;				// State of each DALI Sensor (IDLE / DISABLED / WARNING / OCCUPANCY)
}

// Message to get or set Admin Properties in reference to the network connection. Will require a device reboot to update - Used with AdminMessage
message AdminNetworkPropertiesMessage {
    bool DHCP           = 1; // Should DHCP be used? If False, the static IP will be used instead
    string IP           = 2; // A static IP to use if DHCP is False
    string MAC          = 3; // The MAC Address of this Device
    string gateway      = 4; // The Gateway IP for the network this Device is on
	string NTPServer    = 5; // The NTP Server address from RTC updates over the network
	bool NTP            = 6; // Should NTP be used to keep the RTC up-to-date via network requests
    string error        = 7; // Error or Status Message 32 char
    uint32 NTPTimeout   = 8; // Timeout in seconds for NTP Retry
    string subnet       = 9; // The Subnet if set by Static IP
    string DNS_Primary  = 10;   // Primary DNS
    string DNS_Secondary = 11;  // Secondary DNS
}

// Message to set the DNS Server - Used with AdmiMessage
message AdminDNSServersMessage {
    string DNS_Primary      = 1; // Primary DNS
    string DNS_Secondary    = 2; // Secondary DNS
}

// Message to set the Type of Controller lines - Used with AdminMessage
message AdminControllerLinesMessage {
    repeated LineType lines     = 1; // Used to set the control type on each control line (e.g. DMX / DALI)
}

// Message to get device temperature and battery - Used with AdminMessage
message AdminDeviceStatusMessage {
    float temperature   = 1; // The current device chip temperature
    float battery       = 2; // The current battery voltage (3.3V battery)
}

// Message to enable/disable the Secure Login functionality
message AdminSecureLoginMessage {
    string username         = 1; // Which username to login as
    string cnonce           = 2; // The nonce generated by the client attempting to login
    repeated uint32 hash    = 3; // The hash of the server nonce + client nonce + client password, encrypted using AES CTR
}

// Message to set the DALI sensor messaging type (24 or 25 bit DALI)  - Used with AdminMessage
message AdminDALISensorTypeMessage {
    DALISensorType type     = 1; // Which type of eDALI will the eDIDIO use to decode & encode Sensor packets?
}

// The Main AdminMessage used with the specific oneoff message type. 
message AdminMessage {
    AdminCommandType command                              = 1; // What type of Command to run (GET / SET / etc.)
    AdminPropertyType target                              = 2; // Which property to run the Command on
    oneof payload {
        PayloadMessage data                               = 3;
        AdminNetworkPropertiesMessage network_properties  = 4;
        AdminProjectPropertiesMessage project_properties  = 5;
        AdminControllerLinesMessage controller_lines      = 6;
		AdminDeviceStatusMessage device_status			  = 7;
		AdminConfigStatusMessage config_status 			  = 8;
		UpdateTimeMessage device_time					  = 9;
        AdminDALISensorTypeMessage dali_sensor_type       = 10;
        AdminDNSServersMessage dns_servers                = 11;
    }
}

/************ @exclude FIRMWARE UPDATE ********/
// Simple free-form binary data blob that can be used for chunk transfer.
message DataMessage {
    uint32 identifier     = 1; // A free-form number that indicates exactly what type of data is being dealt with. Eg. 0x99 may indicate a firmware flash.
    uint32 seq            = 2; // The message position in the sequence.
    uint32 count          = 3; // The expected total number of DataMessages to be sent. When seq == count, you know you've got the last chunk and can go ahead and process the data (eg. flash firmware).
    repeated uint32 data  = 4;
}

// Firmware Update Meta Message. Contains information on new incoming firmware. Sending this message begins the update process and will ERASE the currently stored firmware
message FirmwareMetaMessage {
	uint32 firmware_version 			 = 1; // MSB.XXX.LSB
	uint32 firmware_date	 			 = 2; // Day/Month/Year Compiled - Deprecated, use tag = 10, 11, 12
	uint32 firmware_date_upload          = 3; // Day/Month/Year Uploaded - Deprecated, uses controller time
	uint32 firmware_checksum		     = 4; // Checksum to verify data
	uint32 firmware_chunk_count	         = 5; // Number of stored chunks
	uint32 firmware_base_address 	     = 6; // Base Address of the Firmware
	uint32 firmware_end_address	         = 7; // End Address - For sector erases
    bool firmware_is_backup              = 8; // Flag to send Firmware to 'Backup' Location
    repeated uint32 nonce                = 9; // Decryption Nonce
    uint32 firmware_date_day             = 10; // Day in Firmware File
    uint32 firmware_date_month           = 11; // Month in Firmware File
    uint32 firmware_date_year            = 12; // Year in Firmware File 
}

// Reply from eDIDIO, or command from program. eDIDIO will check firmware before 'Apply'
message FirmwareControlMessage {
	FirmwareCommandType cmd  = 1;
    bool firmware_is_backup  = 2; // Flag used for FW_READ, FW_VERIFY, and FW_CLONE. Does not work for FW_APPLY
}

// Chunk of firmware to be sent via a 256 byte payload
message FirmwareChunkMessage {
	uint32 firmware_address       = 1;
	uint32 total_bytes            = 2;
    DataMessage payload           = 3;
}


/************ @exclude SYSTEM LOGGING ************/
// Message sent to read the logs. The start address is offset for how many logs are requested. Up to 32 logs are sent in one message.
message SystemLogReadMessage {
    uint32 log_start_address            = 1;  // Which log to start from
    uint32 logs_requested               = 2;  // How many logs requested? Max of 32
	repeated SystemLogMessage logs      = 3;  // Array of requested logs
}

// Individual Log packet containing oneof log type of information. Logs are timestamped using the timesinceboot parameter. The boot packet will provide the time of boot, so exact times can be extracted
message SystemLogMessage {
	uint32 time_since_boot              = 1;	// Time since boot (From latest power message)
	oneof packet {                           
		SystemLogBoot boot              = 2;
		SystemLogNetLink netlink        = 3;
		SystemLogNTP ntp                = 4;
		SystemLogTrigger trigger        = 5;
		SystemLogSpektra spektra        = 6;
		SystemLogSchedule schedule      = 7;
		SystemLogUserStart userstart    = 8;		
	}
}

// Message for Log Boot Type
message SystemLogBoot {
	TimeClockMessage timeclock  = 1;
	uint32 flags                = 2;
}

// Message for Log Netlink Type
message SystemLogNetLink {
	bool is_linked              = 1;
}

// Message for Log NTP Type
message SystemLogNTP {
	TimeClockMessage timeclock  = 1;
}

// Message for Log Trigger Type
message SystemLogTrigger {
	TriggerMessage trigger      = 1;
	ReadType source             = 2;
}

// Message for Log Spektra Type
message SystemLogSpektra {
	SpektraActionType action    = 1;
	SpektraTargetType type      = 2;
	uint32 index                = 3;
}

// Message for Log Schedule Type
message SystemLogSchedule {
	uint32 index    = 1;
	uint32 isStart  = 2;
	uint32 second   = 3;
	uint32 minute   = 4;
	uint32 hour     = 5;
}

// Message for Log User Start Type
message SystemLogUserStart {
	TimeClockMessage timeclock  = 1;
    uint32 flags                = 2;
}

// Message to contain system metadata for debugging purposes
message SystemMetaDataReadMessage {
    repeated uint32 input_press_counter     = 1; // Max 24 Inputs
    repeated uint32 list_start_counter      = 2; // Max 32 Lists
    repeated uint32 schedules_counter       = 3; // Max 10 Alarms
    uint32 screen_on_time                   = 4; // Time in seconds
    uint32 screen_dim_time                  = 5; // Time in seconds
    uint32 screen_saver_time                = 6; // Time in seconds
    uint32 reboot_counter                   = 7; // Number of reboots since Data erased
}

/******************** @exclude Events ******************/
// Message to set Event Filter Mask
message EventFilter {
    bool input                       = 1; // eDIDIO physical inputs
    bool dali_arc_level              = 2; // 16-bit DALI Arc Level Commands
    bool dali_command                = 3; // 16-bit DALI Commands
    bool dali_sensor                 = 4; // DALI Sensors (24-bit and 25-bit Tridonic)
    bool dali_input                  = 5; // 24-bit DALI Inputs
    bool dmx_stream_changed          = 6; // DMX output stream changes
    bool dali_24_frame               = 7; // Raw 24-bit DALI frames
    bool trigger_message             = 8; // High Level Trigger from Input/List/Sensor/Schedule
}

// Message Response for Trigger Event
message TriggerEvent {
    TriggerType type                  = 1; // What type of Trigger occurred
    oneof payload {
        uint32 level                  = 2; // Associated level (if applicable)
        DALICommandType dali_command  = 3; // Associated DALI Command (if applicable)
    }
    uint32 target_address             = 4; // The target address for the TriggerType (if applicable)
    uint32 line_mask                  = 5; // The Line(s) on wich the Trigger occurred (if applicable)
    uint32 zone                       = 6; // The zone of the Trigger (if applicable)
    uint32 value                      = 7; // The value of the Trigger (if applicable)
    uint32 query_index                = 8; // The query_index of the Trigger (if applicable)
    uint32 source                     = 9; // The source of the trigger (input/list/sensor) (if applicable)
}

// Message Response for DALI 24 Input Event
message DALI24InputEvent {
    uint32 index            = 1;
    uint32 line             = 2;
    uint32 address          = 3;
    DALI24InputType type    = 4; // Momentary Short / Momentary Long / Latch Low / Latch High / Positional
    uint32 arg              = 5; // Relevant information for the DALI24InputType
}

// Message Response for DALI 24 Frame Event
message DALI24FrameEvent {
    uint32 line             = 1; // Which DALI Line within the eDIDIO (left -> right): 1, 2, 3, 4
    uint32 frame            = 2; // The 24-bit Frame
}

// Message Response for DALI Sensor Event
message DALISensorEvent {
    uint32 index                            = 1;
    uint32 line                             = 2;
    uint32 address                          = 3;
    DALIMotionSensorStates motion_state     = 4; // Idle / Disabled / Warning / Occupancy
    DALILuxSensorStates lux_state           = 5; // Disabled / Enabled / Deviate
    uint32 lux_level                        = 6;
}

/* A message sent to a client when an event occurs. Depending on the event type (Trigger, Input or Sensor) different data is supplied with the event.
* If a client sends an EventMessage with EventType of REGISTER then broadcast events out to the client.
*/
message EventMessage {
    EventType event                             = 1;
    oneof event_data {
        TriggerEvent trigger                    = 2;
        InputStateResponse inputs               = 3;
        PayloadMessage payload                  = 4;
        // OBSOLETE: JoinedRoomsMessage joined_rooms (5) --> No longer used
        DALISensorEvent sensor                  = 6;
        DALI24InputEvent dali_24_input          = 7;
        EventFilter filter                      = 8;
        DALI24FrameEvent dali_24_frame          = 9;
    }
}

/* Every Message to and from the eDIDIO will be a populated EdidioMessage with a singular payload. 
* The EdidioMessage itself is wrapped with a 0xCD Start Byte and 2 Bytes denoting total Message Length of the form: [Length MSB, Length LSB]
*/
message EdidioMessage
{
    uint32 message_id                                         = 1; // As decided by the client. Will not be unique across clients.
    oneof payload {
        AckMessage ack                                        = 2;
        InputMultiMessage inputs                              = 3;
        OutputMultiMessage outputs                            = 4;
        IRMultiMessage irs                                    = 5;
        SensorMessage sensor                                  = 6;
        // DEPRECATED: SensorMultiMessage (7) --> Send as many SensorMessages as necessary
        ListMessage list                                      = 8;
        // DEPRECATED: ListMultiMessage (9) --> Send as many ListMessages as necessary
        AlarmMessage alarm                                    = 10;
        AlarmMultiMessage alarms                              = 11;
        BurnInMultiMessage burn_ins                           = 12;
        SensorCommandMessage sensor_command                   = 13;
        ChangeProfileMessage change_profile                   = 14;
        IdentifyMessage identify_message                      = 15;
        UpdateTimeMessage update_time                         = 16;
        ReadDeviceMessage read_device                         = 17;
        DALIMessage dali_message                              = 18;
        DALIQueryResponse dali_query                          = 19;
        DMXMessage dmx_message                                = 20;
        ExternalTriggerMessage external_trigger               = 21;
        SpektraSettingMessage spektra_settings                = 22;
        SpektraSequenceConfigMessage spektra_sequence         = 23;
        SpektraCalendarMessage spektra_calendar               = 24;
        SpektraThemeConfigMessage spektra_theme               = 25;
        SpektraReadMessage spektra_read                       = 26;
        SpektraControlMessage spektra_control                 = 27;
        DMXProtocolTranslation dmx_translator                 = 28;
        InputStateMessage  input_request                      = 29; 
        InputStateResponse input_response                     = 30;
        DiagnosticSystemInfoResponse diag_system              = 31;
        DiagnosticMessage diag_message                        = 32;
        AdminMessage admin_message                            = 33;
        EventMessage event                                    = 34;
        SecureDeviceSettingsMessage secure_device_settings    = 35;
        FirmwareMetaMessage firmware_new                      = 36;
        FirmwareControlMessage firmware_control               = 37;
        FirmwareChunkMessage firmware_chunk                   = 38;
        LevelCacheResponse level_cache_response               = 39;
        // OBSOLETE: JoinedRoomsMessage joined_rooms           (40) --> No longer used
        ExtendedListMessage list_extended                     = 41;
        AytMessage ayt_message                                = 42;
        RDMMessage rdm_message                                = 43;
        RDMResponseMessage rdm_response_message               = 44;
        LogicMultiMessage logic_message                       = 45;
        AdminSecureLoginMessage secure_login                  = 46;
        DeviceStateMessage device_state_message               = 47;
        SpektraCalendarDayMessage spektra_calendar_day        = 48;
        SpektraCalendarOverviewMessage spektra_calendar_overview    = 49;
		DALIInputMultiMessage inputs_dali							= 50;
		SystemLogReadMessage logs_read								= 51;
		SystemMetaDataReadMessage metadata_read						= 52;
        DALIAddressingMessage dali_addressing_message               = 53;
        DALIRemappingMessage dali_remapping_message                 = 54;
        // Deprecated: SpektraShowControlMessage spektra_show_control_message      = 55;
        // Deprecated: SpektraShowMessage spektra_show_message                     = 56;
        // Deprecated: ExtendedSpektraShowMessage extended_spektra_show_message    = 57;
        RDMDiscoveryMessage rdm_discovery                           = 58;
        RDMDiscoveryReplyMessage rdm_discovery_reply                = 59;
        DALIIdentifyDuplicatesMessage dali_identify_duplicates      = 60;
        SpektraLiveMessage spektra_live                             = 61;
    }
}